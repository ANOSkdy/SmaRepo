import { query } from '@/lib/db';

export type SessionReportRow = {
  id: string;
  date: string | null;
  year: number | null;
  month: number | null;
  day: number | null;
  start: string | null;
  end: string | null;
  startMs: number | null;
  endMs: number | null;
  durationMin: number | null;
  hours: number | null;
  siteName: string | null;
  siteRecordId: string | null;
  clientName: string | null;
  workDescription: string | null;
  userId: number | null;
  userRecordId: string | null;
  userName: string | null;
  machineId: string | null;
  machineRecordId: string | null;
  machineName: string | null;
  status: string | null;
  autoGenerated: boolean | null;
  isCompleted: boolean;
};

export type SessionReportQuery = {
  siteId?: string | null;
  siteName?: string | null;
  userId?: string | number | null;
  userName?: string | null;
  year?: string | number | null;
  month?: string | number | null;
  day?: string | number | null;
  machineId?: string | number | null;
  workDescription?: string | null;
};

type SessionPayloadRow = { payload: Record<string, unknown> };

type SqlCondition = {
  clause: string;
  value: string | number;
};

function asString(value: unknown): string | null {
  if (typeof value === 'string') {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : null;
  }
  if (typeof value === 'number') {
    return Number.isFinite(value) ? String(value) : null;
  }
  return null;
}

function asNumber(value: unknown): number | null {
  if (typeof value === 'number') return Number.isFinite(value) ? value : null;
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

function asBoolean(value: unknown): boolean | null {
  if (typeof value === 'boolean') return value;
  if (value === 'true') return true;
  if (value === 'false') return false;
  return null;
}

function readFirstString(fields: Record<string, unknown>, keys: readonly string[]): string | null {
  for (const key of keys) {
    const value = fields[key];
    if (Array.isArray(value)) {
      for (const entry of value) {
        const text = asString(entry);
        if (text) return text;
      }
      continue;
    }
    const text = asString(value);
    if (text) return text;
  }
  return null;
}

function parseDateParts(dateStr: string | null): { year: number | null; month: number | null; day: number | null } {
  if (!dateStr) return { year: null, month: null, day: null };
  const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!match) return { year: null, month: null, day: null };
  return { year: Number(match[1]), month: Number(match[2]), day: Number(match[3]) };
}

function toSessionRow(payload: Record<string, unknown>): SessionReportRow | null {
  const fields =
    payload.fields && typeof payload.fields === 'object' && !Array.isArray(payload.fields)
      ? (payload.fields as Record<string, unknown>)
      : payload;
  const date = asString(fields.date);
  const dateParts = parseDateParts(date);
  const start = readFirstString(fields, ['start', 'start (JST)']);
  const end = readFirstString(fields, ['end', 'end (JST)']);
  const durationMin = asNumber(fields.durationMin);
  const startMs = start ? Date.parse(start) : Number.NaN;
  const endMs = end ? Date.parse(end) : Number.NaN;
  const normalizedStartMs = Number.isFinite(startMs) ? startMs : null;
  const normalizedEndMs = Number.isFinite(endMs) ? endMs : null;
  const hours = durationMin != null ? Math.round((durationMin / 60) * 10) / 10 : null;

  return {
    id: asString(fields.id) ?? asString(payload.id) ?? `${date ?? 'session'}-${normalizedStartMs ?? 0}`,
    date,
    year: dateParts.year,
    month: dateParts.month,
    day: dateParts.day,
    start,
    end,
    startMs: normalizedStartMs,
    endMs: normalizedEndMs,
    durationMin,
    hours,
    siteName: readFirstString(fields, ['siteName', 'site name']),
    siteRecordId: Array.isArray(fields.site) ? asString(fields.site[0]) : asString(fields.siteRecordId),
    clientName: readFirstString(fields, ['clientName', 'client']),
    workDescription: readFirstString(fields, ['workDescription', 'work description']),
    userId: asNumber(fields.userId ?? fields.user),
    userRecordId: Array.isArray(fields.user) ? asString(fields.user[0]) : asString(fields.userRecordId),
    userName: readFirstString(fields, ['name (from user)', 'userName', 'username', 'name']),
    machineId: readFirstString(fields, ['machineId', 'machineid', 'machineId (from machine)']),
    machineRecordId: Array.isArray(fields.machine) ? asString(fields.machine[0]) : asString(fields.machineRecordId),
    machineName: readFirstString(fields, ['machineName', 'machinename', 'machineName (from machine)']),
    status: asString(fields.status),
    autoGenerated: asBoolean(fields.autoGenerated),
    isCompleted: Boolean(durationMin && durationMin > 0 && normalizedStartMs != null && normalizedEndMs != null),
  };
}

function normalizeText(value: string | null | undefined): string | null {
  return value ? value.trim().toLocaleLowerCase('ja') : null;
}

function toNumber(value: string | number | null | undefined): number | null {
  if (typeof value === 'number') return Number.isFinite(value) ? value : null;
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

function matchesQuery(row: SessionReportRow, q?: SessionReportQuery): boolean {
  if (!q) return true;
  if (q.siteId && row.siteRecordId !== q.siteId) return false;
  if (q.siteName) {
    const e = normalizeText(q.siteName);
    const a = normalizeText(row.siteName);
    if (e && a && e !== a) return false;
  }
  if (q.userName) {
    const e = normalizeText(q.userName);
    const a = normalizeText(row.userName);
    if (e && a && e !== a) return false;
  }
  if (q.userId != null) {
    const e = toNumber(q.userId);
    if (e != null && row.userId !== e) return false;
  }
  if (q.machineId != null) {
    const e = normalizeText(String(q.machineId));
    const a = normalizeText(row.machineId);
    if (e && a && e !== a) return false;
  }
  if (q.workDescription) {
    const e = normalizeText(q.workDescription);
    const a = normalizeText(row.workDescription);
    if (e && a && e !== a) return false;
  }
  if (q.year != null && row.year !== toNumber(q.year)) return false;
  if (q.month != null && row.month !== toNumber(q.month)) return false;
  if (q.day != null && row.day !== toNumber(q.day)) return false;
  return true;
}

export async function fetchSessionReportRows(queryParams?: SessionReportQuery): Promise<SessionReportRow[]> {
  const conditions: SqlCondition[] = [];
  const hasYear = toNumber(queryParams?.year) != null;
  const hasMonth = toNumber(queryParams?.month) != null;
  const hasDay = toNumber(queryParams?.day) != null;

  if (hasYear && hasMonth) {
    const year = toNumber(queryParams?.year)!;
    const month = toNumber(queryParams?.month)!;
    const startDate = `${String(year).padStart(4, '0')}-${String(month).padStart(2, '0')}-01`;
    const end = new Date(Date.UTC(year, month, 1));
    const endDate = `${end.getUTCFullYear()}-${String(end.getUTCMonth() + 1).padStart(2, '0')}-01`;
    conditions.push({ clause: `COALESCE(to_jsonb(s)->>'date', '') >= $${conditions.length + 1}`, value: startDate });
    conditions.push({ clause: `COALESCE(to_jsonb(s)->>'date', '') < $${conditions.length + 1}`, value: endDate });
  } else {
    if (hasYear) {
      conditions.push({
        clause: `COALESCE(split_part(COALESCE(to_jsonb(s)->>'date', ''), '-', 1), '') = $${conditions.length + 1}`,
        value: String(toNumber(queryParams?.year)!).padStart(4, '0'),
      });
    }
    if (hasMonth) {
      conditions.push({
        clause: `COALESCE(split_part(COALESCE(to_jsonb(s)->>'date', ''), '-', 2), '') = $${conditions.length + 1}`,
        value: String(toNumber(queryParams?.month)!).padStart(2, '0'),
      });
    }
  }

  if (hasDay) {
    conditions.push({
      clause: `COALESCE(split_part(COALESCE(to_jsonb(s)->>'date', ''), '-', 3), '') = $${conditions.length + 1}`,
      value: String(toNumber(queryParams?.day)!).padStart(2, '0'),
    });
  }

  const normalizedUserId = toNumber(queryParams?.userId);
  if (normalizedUserId != null) {
    conditions.push({
      clause: `COALESCE(to_jsonb(s)->>'userId', to_jsonb(s)->>'user', '') = $${conditions.length + 1}`,
      value: String(normalizedUserId),
    });
  }

  if (queryParams?.siteId) {
    conditions.push({
      clause: `COALESCE(to_jsonb(s)->'site'->>0, to_jsonb(s)->>'siteRecordId', '') = $${conditions.length + 1}`,
      value: queryParams.siteId,
    });
  }

  if (queryParams?.machineId) {
    conditions.push({
      clause: `COALESCE(to_jsonb(s)->>'machineId', to_jsonb(s)->>'machineid', to_jsonb(s)->'machine'->>0, '') = $${conditions.length + 1}`,
      value: String(queryParams.machineId),
    });
  }

  const whereClause =
    conditions.length > 0
      ? `WHERE ${conditions.map((condition) => condition.clause).join('\n        AND ')}`
      : '';

  const result = await query<SessionPayloadRow>(
    `
      SELECT to_jsonb(s) AS payload
      FROM sessions s
      ${whereClause}
      ORDER BY
        COALESCE(to_jsonb(s)->>'date', '') ASC,
        COALESCE(to_jsonb(s)->>'start', '') ASC,
        COALESCE(to_jsonb(s)->>'id', '') ASC
    `,
    conditions.map((condition) => condition.value),
  );

  return result.rows
    .map((row) => toSessionRow(row.payload))
    .filter((row): row is SessionReportRow => row !== null && row.date !== null)
    .filter((row) => matchesQuery(row, queryParams));
}
