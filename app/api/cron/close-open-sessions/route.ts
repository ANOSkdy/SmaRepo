import { NextResponse } from 'next/server';
import { withClient } from '@/lib/db';
import { hasDatabaseUrl } from '@/lib/server-env';

export const runtime = 'nodejs';

type OpenInRow = {
  payload: Record<string, unknown>;
};

const JST_FORCED_TIME = process.env.FORCED_OUT_JST_TIME || '17:30';
const MIN_GAP_MINUTES = Number(process.env.FORCED_OUT_MIN_GAP_MINUTES ?? 5);
const MAX_HOURS_PER_DAY = Number(process.env.FORCED_OUT_MAX_HOURS_PER_DAY ?? 12);

function toYmdJst(date = new Date()) {
  const jstMs = date.getTime() + 9 * 60 * 60 * 1000;
  const jst = new Date(jstMs);
  return `${jst.getUTCFullYear()}-${String(jst.getUTCMonth() + 1).padStart(2, '0')}-${String(jst.getUTCDate()).padStart(2, '0')}`;
}

function parseForcedOutAt(dateJst: string): Date {
  const hm = JST_FORCED_TIME.length === 5 ? `${JST_FORCED_TIME}:00` : JST_FORCED_TIME;
  return new Date(`${dateJst}T${hm}+09:00`);
}

function getUserKey(fields: Record<string, unknown>): string {
  const user = fields.user;
  if (Array.isArray(user) && typeof user[0] === 'string' && user[0]) return user[0];
  if (typeof user === 'string' && user) return user;
  if (typeof fields.userId === 'string' && fields.userId) return fields.userId;
  return '';
}

function buildOutPayload(inPayload: Record<string, unknown>, forcedOutIso: string): Record<string, unknown> {
  const fields =
    inPayload.fields && typeof inPayload.fields === 'object' && !Array.isArray(inPayload.fields)
      ? ({ ...(inPayload.fields as Record<string, unknown>) })
      : { ...inPayload };
  fields.type = 'OUT';
  fields.timestamp = forcedOutIso;
  fields.autoGenerated = true;
  fields.forcedSource = 'cron';
  return fields;
}

function verifyCronSecret(req: Request): boolean {
  const secret = process.env.CRON_SECRET;
  if (!secret) return false;
  const header = req.headers.get('x-cron-secret') ?? req.headers.get('authorization')?.replace(/^Bearer\s+/i, '');
  return header === secret;
}

export async function GET(req: Request) {
  if (!hasDatabaseUrl()) {
    return NextResponse.json({ ok: false, error: 'DB env missing' }, { status: 500 });
  }
  if (!verifyCronSecret(req)) {
    return NextResponse.json({ ok: false, error: 'UNAUTHORIZED' }, { status: 401 });
  }

  const { searchParams } = new URL(req.url);
  const dateJst = searchParams.get('date') || toYmdJst();
  const dryRun = searchParams.get('dryRun') === '1';

  try {
    const summary = await withClient(async (client) => {
      await client.query('BEGIN');
      try {
        const openIns = await client.query<OpenInRow>(
          `
            WITH typed AS (
              SELECT to_jsonb(l) AS payload
              FROM logs l
              WHERE COALESCE(to_jsonb(l)->>'date', '') = $1
                AND COALESCE(to_jsonb(l)->>'type', '') IN ('IN', 'OUT')
            ),
            ins AS (
              SELECT payload FROM typed WHERE COALESCE(payload->>'type', '') = 'IN'
            )
            SELECT i.payload
            FROM ins i
            WHERE NOT EXISTS (
              SELECT 1
              FROM typed t
              WHERE COALESCE(t.payload->>'type', '') = 'OUT'
                AND COALESCE(t.payload->>'timestamp', '') > COALESCE(i.payload->>'timestamp', '')
                AND COALESCE(t.payload->>'userId', COALESCE(t.payload->'user'->>0, t.payload->>'user', '')) =
                    COALESCE(i.payload->>'userId', COALESCE(i.payload->'user'->>0, i.payload->>'user', ''))
            )
          `,
          [dateJst],
        );

        let createdCount = 0;
        const forcedBase = parseForcedOutAt(dateJst).getTime();

        if (!dryRun) {
          for (const row of openIns.rows) {
            const fields =
              row.payload.fields && typeof row.payload.fields === 'object' && !Array.isArray(row.payload.fields)
                ? (row.payload.fields as Record<string, unknown>)
                : row.payload;
            const inTs = Date.parse(String(fields.timestamp ?? ''));
            const minTs = Number.isFinite(inTs) ? inTs + MIN_GAP_MINUTES * 60_000 : forcedBase;
            const maxTs = Number.isFinite(inTs) ? inTs + MAX_HOURS_PER_DAY * 60 * 60_000 : forcedBase;
            const forcedTs = Math.max(minTs, Math.min(forcedBase, maxTs));
            const payload = buildOutPayload(row.payload, new Date(forcedTs).toISOString());

            await client.query(
              `INSERT INTO logs SELECT * FROM json_populate_record(NULL::logs, $1::json)`,
              [JSON.stringify(payload)],
            );
            createdCount += 1;
          }
        }

        await client.query('COMMIT');
        return {
          ok: true,
          dateJst,
          openInCount: openIns.rows.length,
          createdCount: dryRun ? 0 : createdCount,
          dryRun,
          users: new Set(openIns.rows.map((row) => getUserKey(row.payload))).size,
        };
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      }
    });

    return NextResponse.json(summary);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'internal error';
    return NextResponse.json({ ok: false, error: message }, { status: 500 });
  }
}
